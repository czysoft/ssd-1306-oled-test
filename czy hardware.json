{"README.md":"目前是为了支持minode的v2.2版本核心板而移植的。\r\n\r\n当前发现的问题：\r\n1.switch模块上拉电阻过大，会导致open事件不触发，如果发生，请把10k换成220欧。\r\n2.人体红外检测模块(PIR)有点问题，10k的限流电阻太大，核心板读到的pin状态不对，拉不上来。a脚不重复设置，显得更不灵了。建议买个更好用模块代替。\r\n3.喇叭模块不能用，给它信号芯片发烫，原始代码里也没有这个功能模块的代码。我自己拿手头的模块做了一个，测试过好用。\r\n\r\n以上三个问题的修正图片在项目img文件夹里，包括喇叭模块的视频。\r\n\r\n## Supported targets\r\n\r\n* for PXT/microbit\r\n(The metadata above is needed for package search.)\r\n\r\n\r\n```package\r\nczyminode=github:czysoft/czyminode\r\n```","czyminode.ts":"\r\n\r\nlet OLED_GRAM: number[][] = [];\r\n//% color=190 weight=100 icon=\"\\uf1ec\" block=\"czy hardware\"\r\n//% groups=['hardware', 'hardware', 'others']\r\nnamespace czyminode {\r\n\r\n\t/**\r\n     * FanOn\r\n     */\r\n    //% blockId=turn_on_fan\r\n    //% block\r\n    export function FanOn(ConnName: ConnNameA): void{\r\n        let p0: DigitalInOutPin;\r\n        let p1: DigitalInOutPin;\r\n\r\n        if (ConnName == ConnNameA.ConnNameA_A0)\r\n        {\r\n            p0= new MicrobitPin(DigitalPin.P0);\r\n            p1 = new MicrobitPin(DigitalPin.P1);\r\n        }\r\n        else if (ConnName == ConnNameA.ConnNameA_A1) {\r\n            p0 = new MicrobitPin(DigitalPin.P1);\r\n            p1 = new MicrobitPin(DigitalPin.P2);\r\n        }\r\n        else if (ConnName == ConnNameA.ConnNameA_A2) {\r\n            p0 = new MicrobitPin(DigitalPin.P2);\r\n            p1 = new MicrobitPin(DigitalPin.P3);\r\n        }\r\n\r\n        p0.digitalWrite(true);\r\n        p1.digitalWrite(false);        \r\n    }\r\n\r\n\t/**\r\n     * FanOff\r\n     */\r\n    //% blockId=turn_off_fan\r\n    //% block\r\n    export function FanOff(ConnName: ConnNameA): void {\r\n        let p0: DigitalInOutPin;\r\n        let p1: DigitalInOutPin;\r\n\r\n        if (ConnName == ConnNameA.ConnNameA_A0) {\r\n            p0 = new MicrobitPin(DigitalPin.P0);\r\n            p1 = new MicrobitPin(DigitalPin.P1);\r\n        }\r\n        else if (ConnName == ConnNameA.ConnNameA_A1) {\r\n            p0 = new MicrobitPin(DigitalPin.P1);\r\n            p1 = new MicrobitPin(DigitalPin.P2);\r\n        }\r\n        else if (ConnName == ConnNameA.ConnNameA_A2) {\r\n            p0 = new MicrobitPin(DigitalPin.P2);\r\n            p1 = new MicrobitPin(DigitalPin.P3);\r\n        }\r\n\r\n        p0.digitalWrite(false);\r\n        p1.digitalWrite(true);     \r\n    }\r\n    function delay(): void {\r\n        basic.pause(1);\r\n    }\r\n    function delayUs(us: number): void {\r\n        let i;\r\n        for (i = 0; i < us; i++) {\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * RgbLed\r\n     */\r\n    //% blockId=RGB_light\r\n    //% block\r\n    export function RgbLed(ConnName: ConnNameD, rgb: number): void {\r\n        let clock: DigitalInOutPin;\r\n        let data: DigitalInOutPin;\r\n\r\n        let num: number = 24;\r\n        let i: number = 0;\r\n        let rgb2: number = rgb;\r\n\r\n        if (ConnName == ConnNameD.ConnNameD_D12) {\r\n            clock = new MicrobitPin(DigitalPin.P12);\r\n            data = new MicrobitPin(DigitalPin.P13);\r\n        }\r\n        else if (ConnName == ConnNameD.ConnNameD_D13) {\r\n            clock = new MicrobitPin(DigitalPin.P13);\r\n            data = new MicrobitPin(DigitalPin.P14);\r\n        }\r\n        else if (ConnName == ConnNameD.ConnNameD_D14) {\r\n            clock = new MicrobitPin(DigitalPin.P14);\r\n            data = new MicrobitPin(DigitalPin.P15);\r\n        }\r\n        else if (ConnName == ConnNameD.ConnNameD_D15) {\r\n            clock = new MicrobitPin(DigitalPin.P15);\r\n            data = new MicrobitPin(DigitalPin.P16);\r\n        }\r\n\r\n        clock.digitalWrite(false);\r\n        data.digitalWrite(false);\r\n\r\n\r\n        for (i = 0; i < 32; i++) {\r\n            data.digitalWrite(false);\r\n\r\n            clock.digitalWrite(true);\r\n            delay();\r\n            clock.digitalWrite(false);\r\n            delay();\r\n        }\r\n\r\n        for (i = 0; i < num; i++) {\r\n            if ((rgb2 & 0x800000)!=0)\r\n                data.digitalWrite(true);\r\n            else\r\n                data.digitalWrite(false);\r\n            rgb2 = rgb2 << 1;\r\n\r\n            clock.digitalWrite(true);\r\n            delay();\r\n            clock.digitalWrite(false);\r\n            delay();\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * SpeakerOut\r\n     */\r\n    //% blockId=Speaker_Out\r\n    //% block=\"SpeakerOut %connName| volume %vol | frequency %frequency | ms %ms\"\r\n    //% shim=czyminode::SpeakerOut\r\n    export function SpeakerOut(ConnName: ConnNameA, vol: number, frequency:number,ms:number): void {\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * test\r\n     */\r\n    //% blockId=test\r\n    //% block\r\n    //% shim=czyminode::test\r\n    export function test(a: number, b: number): number {\r\n        console.log(\"test func\");\r\n        return 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * Get DHT11 temperature (celsius or fahrenheit).\r\n     */\r\n    //% blockId=minode_dht_get_temperature block=\"dht11 %connName| tempreature %FanStatus\" \r\n    export function DHTGetTemperature(connName: ConnNameD, style: DHTTemStyle): number {\r\n        let p0: DigitalInOutPin;\r\n        let p1: DigitalInOutPin;\r\n        let i: number;\r\n        let data: number;\r\n        let temp: number;\r\n        let temp2: number;\r\n        let humi: number;\r\n        //let str: string;\r\n        //let bitarr: number[] = [0,0,0,0,0,0,0,0];\r\n        if (connName == ConnNameD.ConnNameD_D12) {\r\n            p0 = new MicrobitPin(DigitalPin.P12);\r\n            p1 = new MicrobitPin(DigitalPin.P13);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D13) {\r\n            p0 = new MicrobitPin(DigitalPin.P13);\r\n            p1 = new MicrobitPin(DigitalPin.P14);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D14) {\r\n            p0 = new MicrobitPin(DigitalPin.P14);\r\n            p1 = new MicrobitPin(DigitalPin.P15);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D15) {\r\n            p0 = new MicrobitPin(DigitalPin.P15);\r\n            p1 = new MicrobitPin(DigitalPin.P16);\r\n        }\r\n        //������ʼ\r\n        //console.log(\"host start\");\r\n        p0.digitalWrite(false);\r\n        basic.pause(18);\r\n        p0.digitalWrite(true);\r\n        delayUs(30);\r\n\r\n        //console.log(\"wait dht\");\r\n        //dht��Ӧ\r\n        while (p0.digitalRead()) {\r\n            delayUs(1);\r\n        }\r\n        //console.log(\"wait dht 1\");\r\n        let time: number = 0;\r\n        while (p0.digitalRead()==false) {       //�͵�ƽ����\r\n            time++;\r\n        }\r\n        //console.log(\"wait dht 2\");\r\n        time = 0;\r\n        while (p0.digitalRead() == true) {       //�ߵ�ƽ����\r\n            time++;\r\n        }\r\n        //��ʼ������\r\n\r\n        //console.log(\"start get data\");\r\n\r\n        time = 0;\r\n        humi = 0;\r\n        for (i = 0; i < 8; i++) {\r\n            while (p0.digitalRead() == false) {       //�͵�ƽ����\r\n                time++;\r\n            }\r\n            time = 0;\r\n            while (p0.digitalRead() == true) {       //�ߵ�ƽ����\r\n                time++;\r\n            }\r\n            //bitarr[i] = time;\r\n            //console.log(\"bit time:\" + time.toString());\r\n            humi = humi << 1;\r\n            if (time > 7)\r\n                humi |= 1;\r\n        }\r\n\r\n\r\n        //str = \"\";\r\n        //for (i = 0; i < 8;i++) {\r\n        //    str += bitarr[i].toString()+ \",\";\r\n        //}\r\n        //console.log(\"bit:\" + str);\r\n        //time = 0;\r\n        //humi = 0;\r\n        for (i = 0; i < 8; i++) {\r\n            while (p0.digitalRead() == false) {       //�͵�ƽ����\r\n                time++;\r\n            }\r\n            time = 0;\r\n            while (p0.digitalRead() == true) {       //�ߵ�ƽ����\r\n                time++;\r\n            }\r\n            //bitarr[i] = time;\r\n            //console.log(\"bit time:\" + time.toString());\r\n           // humi = humi << 1;\r\n            //if (time > 7)\r\n           //     humi |= 1;\r\n        }\r\n        time = 0;\r\n        temp = 0;\r\n        for (i = 0; i < 8; i++) {\r\n            while (p0.digitalRead() == false) {       //�͵�ƽ����\r\n                time++;\r\n            }\r\n            time = 0;\r\n            while (p0.digitalRead() == true) {       //�ߵ�ƽ����\r\n                time++;\r\n            }\r\n            //bitarr[i] = time;\r\n            //console.log(\"bit time:\" + time.toString());\r\n            temp = temp << 1;\r\n            if (time > 7)\r\n                temp |= 1;\r\n        }\r\n        time = 0;\r\n        temp2 = 0;\r\n        for (i = 0; i < 8; i++) {\r\n            while (p0.digitalRead() == false) {       //�͵�ƽ����\r\n                time++;\r\n            }\r\n            time = 0;\r\n            while (p0.digitalRead() == true) {       //�ߵ�ƽ����\r\n                time++;\r\n            }\r\n            //bitarr[i] = time;\r\n            //console.log(\"bit time:\" + time.toString());\r\n            temp2 = temp2 << 1;\r\n            if (time > 7)\r\n                temp2 |= 1;\r\n        }\r\n\r\n        temp = parseFloat(temp.toString() + \".\" + temp2.toString());\r\n       // console.log(\"humi:\" + humi.toString());\r\n        //console.log(\"temp:\" + temp.toString());\r\n        return temp;\r\n    }\r\n\r\n    /**\r\n     * Get DHT11 Humidity.\r\n     */\r\n    //% blockId=minode_dht_get_humidity block=\"dht11 %connName| humidity\"\r\n    //% advanced=true\r\n    export function DHTGetHumidity(connName: ConnNameD): number {\r\n        let p0: DigitalInOutPin;\r\n        let p1: DigitalInOutPin;\r\n        let i: number;\r\n        let data: number;\r\n        let humi: number;\r\n        if (connName == ConnNameD.ConnNameD_D12) {\r\n            p0 = new MicrobitPin(DigitalPin.P12);\r\n            p1 = new MicrobitPin(DigitalPin.P13);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D13) {\r\n            p0 = new MicrobitPin(DigitalPin.P13);\r\n            p1 = new MicrobitPin(DigitalPin.P14);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D14) {\r\n            p0 = new MicrobitPin(DigitalPin.P14);\r\n            p1 = new MicrobitPin(DigitalPin.P15);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D15) {\r\n            p0 = new MicrobitPin(DigitalPin.P15);\r\n            p1 = new MicrobitPin(DigitalPin.P16);\r\n        }\r\n        //������ʼ\r\n        //console.log(\"host start\");\r\n        p0.digitalWrite(false);\r\n        basic.pause(18);\r\n        p0.digitalWrite(true);\r\n        delayUs(30);\r\n\r\n        //console.log(\"wait dht\");\r\n        //dht��Ӧ\r\n        while (p0.digitalRead()) {\r\n            delayUs(1);\r\n        }\r\n        //console.log(\"wait dht 1\");\r\n        let time: number = 0;\r\n        while (p0.digitalRead() == false) {       //�͵�ƽ����\r\n            time++;\r\n        }\r\n        //console.log(\"wait dht 2\");\r\n        time = 0;\r\n        while (p0.digitalRead() == true) {       //�ߵ�ƽ����\r\n            time++;\r\n        }\r\n        //��ʼ������\r\n\r\n        //console.log(\"start get data\");\r\n\r\n        time = 0;\r\n        humi = 0;\r\n        for (i = 0; i < 8; i++) {\r\n            while (p0.digitalRead() == false) {       //�͵�ƽ����\r\n                time++;\r\n            }\r\n            time = 0;\r\n            while (p0.digitalRead() == true) {       //�ߵ�ƽ����\r\n                time++;\r\n            }\r\n            //console.log(\"bit time:\" + time.toString());\r\n            humi = humi << 1;\r\n            if (time > 7)\r\n                humi |= 1;\r\n        }\r\n\r\n\r\n        return humi;\r\n    }\r\n\r\n    /**\r\n     * Do something when DHT11 temperature change.\r\n     \r\n    //% blockId=minode_on_dhttemperature_change block=\"dht11 %connName| on temperature change\"\r\n    //% advanced=true\r\n    export function onDHTEvent(connName: ConnNameD, body: () => void): void {\r\n        return;\r\n    }\r\n    */\r\n    /**\r\n     * Do something when a switch is opened/closed\r\n     * @param switchId a switch ID .\r\n     * @param connName MiNode Connector Name\r\n     * @param event Event to listen\r\n     */\r\n    //% blockId=minode_on_switch_event block=\"switch %connName| on %event\"\r\n    export function onSwitchEvent(connName: ConnNameD, event: SwitchEvent, body: () => void): void {\r\n        \r\n        let p0: DigitalInOutPin;\r\n        let p1: DigitalInOutPin;\r\n        let lastV: boolean;\r\n        let V: boolean;\r\n        let i: number;\r\n        if (connName == ConnNameD.ConnNameD_D12) {\r\n            p0 = pins.P12;\r\n            p1 = pins.P13;\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D13) {\r\n            p0 = new MicrobitPin(DigitalPin.P13);\r\n            p1 = new MicrobitPin(DigitalPin.P14);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D14) {\r\n            p0 = new MicrobitPin(DigitalPin.P14);\r\n            p1 = new MicrobitPin(DigitalPin.P15);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D15) {\r\n            p0 = new MicrobitPin(DigitalPin.P15);\r\n            p1 = new MicrobitPin(DigitalPin.P16);\r\n        }\r\n        //console.log(\"set switch event\");\r\n        lastV = p0.digitalRead();\r\n        loops.everyInterval(1000, function () {\r\n            V = pins.P12.digitalRead();\r\n            if ((event == SwitchEvent.MINODE_SWITCH_EVT_CLOSE) && (lastV!=V) && (V== false)) {\r\n                //console.log(\"switch event close\");\r\n                body();\r\n                lastV = V;\r\n                return;\r\n            }\r\n            else if ((event == SwitchEvent.MINODE_SWITCH_EVT_OPEN) && (lastV != V) && (V == true)) {\r\n                //console.log(\"switch event open\");\r\n                body();\r\n                lastV = V;\r\n                return;\r\n            }\r\n            lastV = V;\r\n            //console.log(\"switch check event:\" + event + \" V:\" + pins.P12.digitalRead() + \" V2:\" + pins.P13.digitalRead() + \" lastV:\" + lastV);\r\n        })\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Get the switch state (open or not).\r\n     */\r\n    //% blockId=minode_switch_is_opened block=\"switch %connName| is opened\"\r\n    //% advanced=true\r\n    export function switchIsOpened(connName: ConnNameD): boolean {\r\n        let p0: DigitalInOutPin;\r\n        let p1: DigitalInOutPin;\r\n        if (connName == ConnNameD.ConnNameD_D12) {\r\n            p0 = new MicrobitPin(DigitalPin.P12);\r\n            p1 = new MicrobitPin(DigitalPin.P13);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D13) {\r\n            p0 = new MicrobitPin(DigitalPin.P13);\r\n            p1 = new MicrobitPin(DigitalPin.P14);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D14) {\r\n            p0 = new MicrobitPin(DigitalPin.P14);\r\n            p1 = new MicrobitPin(DigitalPin.P15);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D15) {\r\n            p0 = new MicrobitPin(DigitalPin.P15);\r\n            p1 = new MicrobitPin(DigitalPin.P16);\r\n        }\r\n        return p0.digitalRead();\r\n    }\r\n\r\n    /**\r\n     * Do something when MIC level change.\r\n     */\r\n    //% blockId=minode_on_MIC_level_change block=\"mic %connName| > %vol | on noise\"\r\n    //% advanced=true\r\n    export function onMICEvent(connName: ConnNameA,vol:number, body: () => void): void {\r\n        let p0: AnalogInPin;\r\n        let p1: AnalogInPin;\r\n\r\n        if (connName == ConnNameA.ConnNameA_A0) {\r\n            p0 = new MicrobitPin(DigitalPin.P0);\r\n            p1 = new MicrobitPin(DigitalPin.P1);\r\n        }\r\n        else if (connName == ConnNameA.ConnNameA_A1) {\r\n            p0 = new MicrobitPin(DigitalPin.P1);\r\n            p1 = new MicrobitPin(DigitalPin.P2);\r\n        }\r\n        else if (connName == ConnNameA.ConnNameA_A2) {\r\n            p0 = new MicrobitPin(DigitalPin.P2);\r\n            p1 = new MicrobitPin(DigitalPin.P3);\r\n        }\r\n\r\n        loops.everyInterval(50, function () {\r\n            let v:number = p0.analogRead();\r\n            if (Math.abs(v-518) > vol) {\r\n                body();\r\n                return;\r\n            }\r\n\r\n        });\r\n\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Get Mic Volume.\r\n     */\r\n    //% blockId=Mic_Get_Vol block=\"mic %connName| Volume\"\r\n    //% advanced=true\r\n    export function MicGetVol(connName: ConnNameA): number {\r\n        let p0: AnalogInPin;\r\n        let p1: AnalogInPin;\r\n        if (connName == ConnNameA.ConnNameA_A0) {\r\n            p0 = new MicrobitPin(DigitalPin.P0);\r\n            p1 = new MicrobitPin(DigitalPin.P1);\r\n        }\r\n        else if (connName == ConnNameA.ConnNameA_A1) {\r\n            p0 = new MicrobitPin(DigitalPin.P1);\r\n            p1 = new MicrobitPin(DigitalPin.P2);\r\n        }\r\n        else if (connName == ConnNameA.ConnNameA_A2) {\r\n            p0 = new MicrobitPin(DigitalPin.P2);\r\n            p1 = new MicrobitPin(DigitalPin.P3);\r\n        }\r\n        return p0.analogRead();\r\n    }\r\n\r\n\r\n    /**\r\n     * Do something when Rotary change.\r\n     */\r\n    //% blockId=minode_on_ROTARY_CHANGE block=\"rotary %connName| on trigger\"\r\n    export function onRotaryEvent(connName: ConnNameA, body: () => void): void {\r\n        let lastVal: number;\r\n        let p0: AnalogInPin;\r\n        let p1: AnalogInPin;\r\n        if (connName == ConnNameA.ConnNameA_A0) {\r\n            p0 = new MicrobitPin(DigitalPin.P0);\r\n            p1 = new MicrobitPin(DigitalPin.P1);\r\n        }\r\n        else if (connName == ConnNameA.ConnNameA_A1) {\r\n            p0 = new MicrobitPin(DigitalPin.P1);\r\n            p1 = new MicrobitPin(DigitalPin.P2);\r\n        }\r\n        else if (connName == ConnNameA.ConnNameA_A2) {\r\n            p0 = new MicrobitPin(DigitalPin.P2);\r\n            p1 = new MicrobitPin(DigitalPin.P3);\r\n        }\r\n        lastVal = p0.analogRead();\r\n        loops.everyInterval(200, function () {\r\n            let v: number = p0.analogRead();\r\n            if (Math.abs(lastVal - v) > 10) {\r\n                lastVal = v;\r\n                body();\r\n                return;\r\n            }\r\n\r\n        });\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Get Rotary percentage.\r\n     */\r\n    //% blockId=minode_ROTARY_GET_Percentage block=\"rotary %connName| get Percentage\"\r\n    //% advanced=true\r\n    export function RotaryGetPercentage(connName: ConnNameA): number {\r\n        let p0: AnalogInPin;\r\n        let p1: AnalogInPin;\r\n        if (connName == ConnNameA.ConnNameA_A0) {\r\n            p0 = new MicrobitPin(DigitalPin.P0);\r\n            p1 = new MicrobitPin(DigitalPin.P1);\r\n        }\r\n        else if (connName == ConnNameA.ConnNameA_A1) {\r\n            p0 = new MicrobitPin(DigitalPin.P1);\r\n            p1 = new MicrobitPin(DigitalPin.P2);\r\n        }\r\n        else if (connName == ConnNameA.ConnNameA_A2) {\r\n            p0 = new MicrobitPin(DigitalPin.P2);\r\n            p1 = new MicrobitPin(DigitalPin.P3);\r\n        }\r\n\r\n        return p0.analogRead()*100/567;\r\n    }\r\n\r\n    /**\r\n     * Do something when PIR triggered.\r\n     */\r\n    //% blockId=minode_on_PIR_trig block=\"pir %connName| on trigger\"\r\n    //% advanced=true\r\n    export function onPIREvent(connName: ConnNameD, body: () => void): void {\r\n        let p0: DigitalInOutPin;\r\n        let p1: DigitalInOutPin;\r\n        if (connName == ConnNameD.ConnNameD_D12) {\r\n            p0 = new MicrobitPin(DigitalPin.P12);\r\n            p1 = new MicrobitPin(DigitalPin.P13);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D13) {\r\n            p0 = new MicrobitPin(DigitalPin.P13);\r\n            p1 = new MicrobitPin(DigitalPin.P14);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D14) {\r\n            p0 = new MicrobitPin(DigitalPin.P14);\r\n            p1 = new MicrobitPin(DigitalPin.P15);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D15) {\r\n            p0 = new MicrobitPin(DigitalPin.P15);\r\n            p1 = new MicrobitPin(DigitalPin.P16);\r\n        }\r\n        let lastState: boolean = false;\r\n        let state: boolean;\r\n        loops.everyInterval(200, () => {\r\n            state = p0.digitalRead();\r\n            if (state == true && lastState == false) {\r\n                body();\r\n            }\r\n            lastState = state;\r\n        });\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Get the PIR state (trigger or not).\r\n     */\r\n    //% blockId=minode_PIR_istrig block=\"pir %connName| is triggered\"\r\n    //% advanced=true\r\n    export function PIRIsTriggered(connName: ConnNameD): boolean {\r\n        let p0: DigitalInOutPin;\r\n        let p1: DigitalInOutPin;\r\n        if (connName == ConnNameD.ConnNameD_D12) {\r\n            p0 = new MicrobitPin(DigitalPin.P12);\r\n            p1 = new MicrobitPin(DigitalPin.P13);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D13) {\r\n            p0 = new MicrobitPin(DigitalPin.P13);\r\n            p1 = new MicrobitPin(DigitalPin.P14);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D14) {\r\n            p0 = new MicrobitPin(DigitalPin.P14);\r\n            p1 = new MicrobitPin(DigitalPin.P15);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D15) {\r\n            p0 = new MicrobitPin(DigitalPin.P15);\r\n            p1 = new MicrobitPin(DigitalPin.P16);\r\n        }\r\n        return p0.digitalRead();\r\n    }\r\n\r\n    /**\r\n     * Do something when Light level change.\r\n     */\r\n    //% blockId=minode_on_LightSensor_CHANGE block=\"light %connName| on change\"\r\n    export function onLightSensorEvent(connName: ConnNameA, body: () => void): void {\r\n        let p0: AnalogInPin;\r\n        let p1: AnalogInPin;\r\n        if (connName == ConnNameA.ConnNameA_A0) {\r\n            p0 = new MicrobitPin(DigitalPin.P0);\r\n            p1 = new MicrobitPin(DigitalPin.P1);\r\n        }\r\n        else if (connName == ConnNameA.ConnNameA_A1) {\r\n            p0 = new MicrobitPin(DigitalPin.P1);\r\n            p1 = new MicrobitPin(DigitalPin.P2);\r\n        }\r\n        else if (connName == ConnNameA.ConnNameA_A2) {\r\n            p0 = new MicrobitPin(DigitalPin.P2);\r\n            p1 = new MicrobitPin(DigitalPin.P3);\r\n        }\r\n        let light: number = p0.analogRead();\r\n        let lastlight: number = light;\r\n        loops.everyInterval(200, () => {\r\n            light = p0.analogRead();\r\n            if (Math.abs(light - lastlight) > 100)\r\n                body();\r\n            lastlight = light;\r\n        });\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Get Light level.from 1(brightest) to 5(darkness).\r\n     */\r\n    //% blockId=minode_LightSensor_GET_light_level block=\"light %connName| get level\"\r\n    export function LightSensorGetLevel(connName: ConnNameA): number {\r\n        let p0: AnalogInPin;\r\n        let p1: AnalogInPin;\r\n        if (connName == ConnNameA.ConnNameA_A0) {\r\n            p0 = new MicrobitPin(DigitalPin.P0);\r\n            p1 = new MicrobitPin(DigitalPin.P1);\r\n        }\r\n        else if (connName == ConnNameA.ConnNameA_A1) {\r\n            p0 = new MicrobitPin(DigitalPin.P1);\r\n            p1 = new MicrobitPin(DigitalPin.P2);\r\n        }\r\n        else if (connName == ConnNameA.ConnNameA_A2) {\r\n            p0 = new MicrobitPin(DigitalPin.P2);\r\n            p1 = new MicrobitPin(DigitalPin.P3);\r\n        }\r\n        let light: number = p0.analogRead();\r\n\r\n        return  6-Math.floor( light/(1024/6));\r\n    }\r\n\r\n    /**\r\n     * relay control(open / close)\r\n     */\r\n    //% blockId=minode_relay_control block=\"relay %connName| set %status\"\r\n    //% advanced=true\r\n    export function RelayControl(connName: ConnNameD, status: SwitchStatus): void {\r\n\r\n        let p0: DigitalInOutPin;\r\n        let p1: DigitalInOutPin;\r\n        if (connName == ConnNameD.ConnNameD_D12) {\r\n            p0 = pins.P12;\r\n            p1 = pins.P13;\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D13) {\r\n            p0 = new MicrobitPin(DigitalPin.P13);\r\n            p1 = new MicrobitPin(DigitalPin.P14);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D14) {\r\n            p0 = new MicrobitPin(DigitalPin.P14);\r\n            p1 = new MicrobitPin(DigitalPin.P15);\r\n        }\r\n        else if (connName == ConnNameD.ConnNameD_D15) {\r\n            p0 = new MicrobitPin(DigitalPin.P15);\r\n            p1 = new MicrobitPin(DigitalPin.P16);\r\n        }\r\n        p0.digitalWrite(status == SwitchStatus.SWITCH_OPEN);\r\n    }\r\n\r\n    /**\r\n     * i2c\r\n     */\r\n    //% blockId=i2c_ssd1306oledInit block=\"i2c_ssd1306oledInit address:%address\"\r\n    //% advanced=true\r\n    export function i2c_ssd1306oledInit(address: number): void {\r\n        let i: number;\r\n        let j: number;\r\n        OLED_GRAM = [];\r\n        for (i = 0; i < 144; i++) {\r\n            let tmp: number[] = [0, 0, 0, 0, 0, 0, 0, 0];\r\n\r\n            OLED_GRAM.push(tmp);\r\n        }\r\n\r\n        pins.i2cWriteNumber(address, 0xae, NumberFormat.Int16BE, false);        //--turn off oled panel\r\n        pins.i2cWriteNumber(address, 0, NumberFormat.Int16BE, false);           //---set low column address\r\n        pins.i2cWriteNumber(address, 0x10, NumberFormat.Int16BE, false);        //---set high column address\r\n        pins.i2cWriteNumber(address, 0x40, NumberFormat.Int16BE, false);        //--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)\r\n        pins.i2cWriteNumber(address, 0x81, NumberFormat.Int16BE, false);        //--set contrast control register\r\n        pins.i2cWriteNumber(address, 0xCF, NumberFormat.Int16BE, false);        // Set SEG Output Current Brightness\r\n        pins.i2cWriteNumber(address, 0xA1, NumberFormat.Int16BE, false);        //--Set SEG/Column Mapping     0xa0���ҷ��� 0xa1����\r\n        pins.i2cWriteNumber(address, 0xC8, NumberFormat.Int16BE, false);        //Set COM/Row Scan Direction   0xc0���·��� 0xc8����\r\n        pins.i2cWriteNumber(address, 0xA6, NumberFormat.Int16BE, false);        //--set normal display\r\n        pins.i2cWriteNumber(address, 0xA8, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0x3f, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0xD3, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0x00, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0xd5, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0x80, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0xD9, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0xF1, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0xDA, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0x12, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0xDB, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0x40, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0x20, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0x02, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0x8D, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0x14, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0xA4, NumberFormat.Int16BE, false);\r\n        pins.i2cWriteNumber(address, 0xA6, NumberFormat.Int16BE, false);\r\n        i2c_ssd1306oledClear(address);\r\n        //pins.i2cWriteNumber(address, 0x2e, NumberFormat.Int16BE, false);        //�رչ���\r\n        pins.i2cWriteNumber(address, 0xAF, NumberFormat.Int16BE, false);\r\n\r\n    }\r\n    /**\r\n     * i2c_ssd1306oledClear\r\n     */\r\n    //% blockId=i2c_ssd1306oledClear block=\"i2c_ssd1306oledClear address:%address\"\r\n    //% advanced=true\r\n    export function i2c_ssd1306oledClear(address: number): void {\r\n        let i: number;\r\n        let j: number;\r\n        for (i = 0; i < 144; i++) {\r\n            for (j = 0; j < 8; j++) {\r\n                OLED_GRAM[i][j] = 0;\r\n            }\r\n        }\r\n        let buf: Buffer = Buffer.create(1 + 128);\r\n        buf[0] = 0x40;\r\n        for (i = 0; i < 8; i++) {\r\n            pins.i2cWriteNumber(address, 0xb0 + i, NumberFormat.Int16BE, false);            //����ҳ��ַ\r\n            pins.i2cWriteNumber(address, 0, NumberFormat.Int16BE, false);                   //���õ�����ʼ��ַ\r\n            pins.i2cWriteNumber(address, 0x10, NumberFormat.Int16BE, false);                //���ø�����ʼ��ַ\r\n\r\n            pins.i2cWriteBuffer(address, buf, false);\r\n        }\r\n    }\r\n    /**\r\n     * i2c_ssd1306oledRefresh\r\n     */\r\n    //% blockId=i2c_ssd1306oledRefresh block=\"i2c_ssd1306oledRefresh address:%address\"\r\n    //% advanced=true\r\n    export function i2c_ssd1306oledRefresh(address: number): void {\r\n        let i: number;\r\n        let n: number;\r\n        let buf: Buffer = Buffer.create(129);\r\n        buf[0] = 0x40;\r\n        for (i = 0; i < 8; i++) {\r\n            pins.i2cWriteNumber(address, 0xb0 + i, NumberFormat.Int16BE, false);            //��������ʼ��ַ\r\n            pins.i2cWriteNumber(address, 0, NumberFormat.Int16BE, false);                   //���õ�����ʼ��ַ\r\n            pins.i2cWriteNumber(address, 0x10, NumberFormat.Int16BE, false);                //���ø�����ʼ��ַ\r\n\r\n            for (n = 0; n < 128; n++)\r\n                buf[n + 1] = OLED_GRAM[n][i];\r\n            pins.i2cWriteBuffer(address, buf, false);\r\n        }\r\n\r\n    }\r\n    /**\r\n     * i2c_ssd1306oledPixel\r\n     */\r\n    //% blockId=i2c_ssd1306oledPixel block=\"i2c_ssd1306oledPixel address:%address | x:%x | y:%y | show:%show | direct:%direct\"\r\n    //% advanced=true\r\n    export function i2c_ssd1306oledPixel(address: number, x: number, y: number, show: boolean, direct:boolean): void {\r\n        let i: number=y/8;\r\n        let m: number=y%8;\r\n        let n: number=1<<m;\r\n\r\n        if (show) {\r\n            OLED_GRAM[x][i] |= n;\r\n        }\r\n        else {\r\n            OLED_GRAM[x][i] = ~OLED_GRAM[x][i];\r\n            OLED_GRAM[x][i] |= n;\r\n            OLED_GRAM[x][i] = ~OLED_GRAM[x][i];\r\n        }\r\n        if (direct) {\r\n            pins.i2cWriteNumber(address, 0xb0 + i, NumberFormat.Int16BE, false);                    //����ҳ��ַ\r\n            pins.i2cWriteNumber(address, x & 0xf, NumberFormat.Int16BE, false);                     //���õ�����ʼ��ַ\r\n            pins.i2cWriteNumber(address, 0x10 + ((x & 0xf0) >> 4), NumberFormat.Int16BE, false);                //���ø�����ʼ��ַ\r\n\r\n            pins.i2cWriteNumber(address, 0x4000 + OLED_GRAM[x][i], NumberFormat.UInt16BE, false);\r\n        }\r\n    }\r\n    /**\r\n     * i2c_ssd1306oledDrawLine\r\n     */\r\n    //% blockId=i2c_ssd1306oledDrawLine block=\"i2c_ssd1306oledDrawLine address:%address | x1:%x1 | y1:%y1 | x2:%x2 | y2:%y2 | show:%show | direct:%direct\"\r\n    //% advanced=true\r\n    export function i2c_ssd1306oledDrawLine(address: number, x1: number, y1: number, x2: number, y2: number, show: boolean, direct: boolean): void {\r\n        \r\n        let t: number; \r\n        let xerr: number = 0, yerr: number = 0, delta_x: number, delta_y: number, distance: number;\r\n        let incx: number, incy: number, uRow: number, uCol: number;\r\n\r\n        delta_x = x2 - x1; //������������ \r\n        delta_y = y2 - y1;\r\n        uRow = x1;//�����������\r\n        uCol = y1;\r\n        if (delta_x > 0)\r\n            incx = 1; //���õ������� \r\n        else if (delta_x == 0)\r\n            incx = 0;//��ֱ�� \r\n        else\r\n        {\r\n            incx = -1;\r\n            delta_x = -delta_x;\r\n        }\r\n        if (delta_y > 0)\r\n            incy = 1;\r\n        else if (delta_y == 0)\r\n            incy = 0;//ˮƽ�� \r\n        else {\r\n            incy = -1;\r\n            delta_y = -delta_x;\r\n        }\r\n        if (delta_x > delta_y)\r\n            distance = delta_x; //ѡȡ�������������� \r\n        else\r\n            distance = delta_y;\r\n\r\n        for (t = 0; t < distance + 1; t++) {\r\n            //console.log(uRow + \":\" + uCol);\r\n            i2c_ssd1306oledPixel(address,uRow, uCol,show, false);//����\r\n            xerr += delta_x;\r\n            yerr += delta_y;\r\n            if (xerr > distance) {\r\n                xerr -= distance;\r\n                uRow += incx;\r\n            }\r\n            if (yerr > distance) {\r\n                yerr -= distance;\r\n                uCol += incy;\r\n            }\r\n        }\r\n        if (direct)\r\n            i2c_ssd1306oledRefresh(address);\r\n    }/**\r\n     * i2c_ssd1306oledDrawCircle\r\n     */\r\n    //% blockId=i2c_ssd1306oledDrawCircle block=\"i2c_ssd1306oledDrawCircle address:%address | x:%x | y:%y | r:%r | show:%show | direct:%direct\"\r\n    //% advanced=true\r\n    export function i2c_ssd1306oledDrawCircle(address: number, x: number, y: number, r: number, show: boolean, direct: boolean): void {\r\n\r\n        let a: number, b: number, num: number;\r\n        a = 0;\r\n        b = r;\r\n        while (2 * b * b >= r * r) {\r\n            console.log((x + a) + \":\" + (y - b));\r\n            i2c_ssd1306oledPixel(address, x + a, y - b, show,false);\r\n            i2c_ssd1306oledPixel(address, x - a, y - b, show, false);\r\n            i2c_ssd1306oledPixel(address, x - a, y + b, show, false);\r\n            i2c_ssd1306oledPixel(address, x + a, y + b, show, false);\r\n\r\n            i2c_ssd1306oledPixel(address, x + b, y + a, show, false);\r\n            i2c_ssd1306oledPixel(address, x + b, y - a, show, false);\r\n            i2c_ssd1306oledPixel(address, x - b, y - a, show, false);\r\n            i2c_ssd1306oledPixel(address, x - b, y + a, show, false);\r\n\r\n            a++;\r\n            num = (a * a + b * b) - r * r;//���㻭�ĵ���Բ�ĵľ���\r\n            if (num > 0) {\r\n                b--;\r\n                a--;\r\n            }\r\n        }\r\n        if (direct)\r\n            i2c_ssd1306oledRefresh(address);\r\n    }\r\n}\r\n","enums.d.ts":"// Auto-generated. Do not edit.\n\n\n    declare const enum AnalogConnName\n    {\n    //% block=\"A0\" enumval=0\n    Analog_A0 = 0,\n    //% block=\"A1\" enumval=1\n    Analog_A1 = 1,\n    //% block=\"A2\" enumval=2\n    Analog_A2 = 2,\n    //% block=\"NC\" enumval=-1\n    Analog_MN_NC = -1,\n    }\n\n\n    declare const enum SwitchEvent {\n    //% block=\"open\" enumval=1\n    MINODE_SWITCH_EVT_OPEN = 1,\n    //% block=\"close\" enumval=2\n    MINODE_SWITCH_EVT_CLOSE = 2,\n    }\n\n\n    declare const enum DHTTemStyle {\n    //% block=\"Celsius\" enumval=1\n    MINODE_DHT_CELSIUS = 1,\n    //% block=\"Fahrenheit\" enumval=2\n    MINODE_FAN_FAHRENHEIT = 2,\n    }\n\n\n    declare const enum ConnNames {\n    //% block=\"A0\" enumval=1\n    A0 = 1,\n    //% block=\"A1\" enumval=2\n    A1 = 2,\n    //% block=\"A2\" enumval=3\n    A2 = 3,\n    //% block=\"D12\" enumval=4\n    D12 = 4,\n    //% block=\"D13\" enumval=5\n    D13 = 5,\n    //% block=\"D14\" enumval=6\n    D14 = 6,\n    //% block=\"D15\" enumval=7\n    D15 = 7,\n    //% block=\"I2C7\" enumval=8\n    I2C1 = 8,\n    //% block=\"I2C2\" enumval=9\n    I2C2 = 9,\n    //% block=\"I2C3\" enumval=10\n    I2C3 = 10,\n    }\n\n\n    declare const enum ConnNameA {\n    //% block=\"A0\" enumval=1\n    ConnNameA_A0 = 1,\n    //% block=\"A1\" enumval=2\n    ConnNameA_A1 = 2,\n    //% block=\"A2\" enumval=3\n    ConnNameA_A2 = 3,\n    }\n\n\n    declare const enum ConnNameD {\n    //% block=\"D12\" enumval=4\n    ConnNameD_D12 = 4,\n    //% block=\"D13\" enumval=5\n    ConnNameD_D13 = 5,\n    //% block=\"D14\" enumval=6\n    ConnNameD_D14 = 6,\n    //% block=\"D15\" enumval=7\n    ConnNameD_D15 = 7,\n    }\n\n\n    declare const enum SwitchStatus {\n    //% block=\"open\" enumval=1\n    SWITCH_OPEN = 1,\n    //% block=\"close\" enumval=2\n    SWITCH_CLOSE = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n","libs/czyminode.cpp":"#include \"pxt.h\"\r\n\r\n#include <mbed.h>\r\n#include <cstdint>\r\n#include <math.h>\r\n\r\n\r\nusing namespace pxt;\r\nusing namespace pins;\r\n\r\nenum AnalogConnName\r\n{\r\n    //% block=\"A0\" enumval=0\r\n    Analog_A0 = 0,\r\n    //% block=\"A1\" enumval=1\r\n    Analog_A1 = 1,\r\n    //% block=\"A2\" enumval=2\r\n    Analog_A2 = 2,\r\n    //% block=\"NC\" enumval=-1\r\n    Analog_MN_NC = -1\r\n};\r\nenum SwitchEvent {\r\n    //% block=\"open\" enumval=1\r\n    MINODE_SWITCH_EVT_OPEN = 1,\r\n    //% block=\"close\" enumval=2\r\n    MINODE_SWITCH_EVT_CLOSE = 2,\r\n};\r\nenum DHTTemStyle {\r\n    //% block=\"Celsius\" enumval=1\r\n    MINODE_DHT_CELSIUS = 1,\r\n    //% block=\"Fahrenheit\" enumval=2\r\n    MINODE_FAN_FAHRENHEIT = 2,\r\n};\r\n\r\nenum ConnNames {\r\n    //% block=\"A0\" enumval=1\r\n    A0 = 1,\r\n    //% block=\"A1\" enumval=2\r\n    A1 = 2,\r\n    //% block=\"A2\" enumval=3\r\n    A2 = 3,\r\n    //% block=\"D12\" enumval=4\r\n    D12 = 4,\r\n    //% block=\"D13\" enumval=5\r\n    D13 = 5,\r\n    //% block=\"D14\" enumval=6\r\n    D14 = 6,\r\n    //% block=\"D15\" enumval=7\r\n    D15 = 7,\r\n    //% block=\"I2C7\" enumval=8\r\n    I2C1 = 8,\r\n    //% block=\"I2C2\" enumval=9\r\n    I2C2 = 9,\r\n    //% block=\"I2C3\" enumval=10\r\n    I2C3 = 10\r\n};\r\nenum ConnNameA {\r\n    //% block=\"A0\" enumval=1\r\n    ConnNameA_A0 = 1,\r\n    //% block=\"A1\" enumval=2\r\n    ConnNameA_A1 = 2,\r\n    //% block=\"A2\" enumval=3\r\n    ConnNameA_A2 = 3\r\n};\r\nenum ConnNameD {\r\n    //% block=\"D12\" enumval=4\r\n    ConnNameD_D12 = 4,\r\n    //% block=\"D13\" enumval=5\r\n    ConnNameD_D13 = 5,\r\n    //% block=\"D14\" enumval=6\r\n    ConnNameD_D14 = 6,\r\n    //% block=\"D15\" enumval=7\r\n    ConnNameD_D15 = 7\r\n};\r\n\r\nenum SwitchStatus {\r\n    //% block=\"open\" enumval=1\r\n    SWITCH_OPEN = 1,\r\n    //% block=\"close\" enumval=2\r\n    SWITCH_CLOSE = 2,\r\n};\r\nnamespace czyminode {\r\n\r\n\r\n\t//%\r\n\tint test(int a, int b)\r\n\t{\r\n\t\treturn a + b;\r\n\t}\r\n\r\n\t//%\r\n\tvoid SpeakerOut(AnalogConnName ConnName, int vol, int frequency,int ms)\r\n\t{\r\n        bool b1 = true;\r\n        //uBit.io.P16.getDigitalValue\r\n\r\n        MicroBitPin* p0;\r\n\t\tif (ConnName == Analog_A0)\r\n\t\t\tp0 = getPin(MICROBIT_ID_IO_P0);\r\n\t\telse if (ConnName == Analog_A1)\r\n\t\t\tp0 = getPin(MICROBIT_ID_IO_P1);\r\n\t\telse if (ConnName == Analog_A2)\r\n\t\t\tp0 = getPin(MICROBIT_ID_IO_P2);\r\n        else\r\n        {\r\n            uBit.serial.printf(\"ConnName error\\r\\n\");\r\n            return;\r\n        }\r\n        p0->setAnalogValue(vol);\r\n        p0->setAnalogPeriodUs(1000000 / frequency);\r\n        sleep_us(ms*1000);\r\n        p0->setAnalogValue(0);\r\n\r\n        ////fiber_sleep(ms);\r\n        //for (int i = 0; i < 10000; i++)\r\n        //{\r\n        //    p0->setAnalogValue(b1?-1000:1000);\r\n        //    sleep_us(500);\r\n        //    b1 = !b1;\r\n        //}\r\n        //\r\n\t\treturn;\r\n\t}\r\n}","main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","pxt.json":"{\n    \"name\": \"czy hardware\",\n    \"version\": \"1.0.3\",\n    \"description\": \"stm32 minode ...\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.blocks\",\n        \"czyminode.ts\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"libs/czyminode.cpp\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"branch\": \"v5.0.13\",\n        \"tag\": \"v5.0.13\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/a69388ca86364c33012c2814a6e4b1f547bf3bca\",\n        \"target\": \"5.0.13\",\n        \"pxt\": \"8.0.7\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n\n    //% weight=2 color=#9900CC icon=\"\\uf53b\"\ndeclare namespace czyminode {\n}\n\n// Auto-generated. Do not edit. Really.\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\nbasic.forever(() => {\n    czyminode.FanOn(ConnNameA.ConnNameA_A0);\n})"}